<!DOCTYPE html>
<html>
<head>
    <title>瑟瑟连连看</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            touch-action: manipulation;
        }

        #gameContainer {
            position: relative;
            margin: 20px;
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
            transform-origin: top center;
        }

        .cell {
            position: absolute;
            border: 1px solid #e5e5e5;
            cursor: pointer;
            background-size: cover;
            transition: opacity 0.3s;
        }

        #header {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 10px;
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 16px;
        }

        #modeSelect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .weui-btn {
            position: relative;
            display: block;
            width: 280px;
            margin: 20px auto;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            border: none;
            color: #fff;
            background: #07c160;
            line-height: 1.4;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }

        .weui-btn:active {
            background: #06ad56;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #controlPanel {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .dialog-mask {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            z-index: 1000;
        }

        .dialog-content {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            display: none;
            z-index: 1001;
        }

        .path-line {
            position: absolute;
            background: #ff4757;
            pointer-events: none;
            z-index: 100;
            transition: all 0.3s;
        }

        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.5; }
        }

        @media screen and (max-width: 600px) {
            #gameContainer {
                transform: scale(1.8);
                margin: 60px 0;
            }
            .weui-btn {
                width: 220px;
                padding: 20px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="modeSelect">
        <h1 style="color:#07c160;font-size:36px;margin-bottom:40px;">瑟瑟连连看</h1>
        <button class="weui-btn" onclick="startGame('easy')">简单模式</button>
        <button class="weui-btn" onclick="startGame('normal')">标准模式</button>
        <button class="weui-btn" onclick="startGame('hard')">高难模式</button>
    </div>

    <div id="header" style="display: none;">
        <div>局数: <span id="round">1</span></div>
        <div>时间: <span id="timer">0</span>秒</div>
        <div>最佳: <span id="best">-</span></div>
    </div>

    <div id="gameContainer"></div>

    <div id="controlPanel" style="display: none;">
        <button class="weui-btn" style="width:160px;" onclick="backToHome()">返回首页</button>
        <button class="weui-btn" style="width:160px;" onclick="restart()">重新开始</button>
        <button class="weui-btn" style="width:160px;" onclick="location.href='https://www.thisnet.cn/wxurl/mini.php'">联系作者</button>
    </div>

    <div id="dialogMask" class="dialog-mask"></div>
    <div id="dialogContent" class="dialog-content">
        <h2 style="color:#07c160;margin-bottom:20px;">你真棒！</h2>
        <button class="weui-btn" style="background:#07c160;" onclick="location.href='https://www.thisnet.cn/wxurl/mini.php'">现在瑟瑟</button>
        <button class="weui-btn" style="background:#576b95;" onclick="restart()">再来一局</button>
    </div>

<script>
// 游戏配置
const MODE_CONFIG = {
    easy:    { rows: 4,  cols: 6,  pics: 6  }, // 4x6=24格
    normal:  { rows: 6,  cols: 8,  pics: 12 }, // 6x8=48格
    hard:    { rows: 8,  cols: 12, pics: 24 }  // 8x12=96格
};
const CELL_SIZE = 80; // 基础单元格尺寸
const ALL_IMAGES = Array.from({length:48}, (_,i) => 10001 + i);

let gameState = {
    mode: null,
    selected: null,
    cells: [],
    images: [],
    startTime: null,
    timerId: null,
    bestTime: localStorage.getItem('bestTime') || Infinity
};

// 初始化显示最佳成绩
document.getElementById('best').textContent = 
    gameState.bestTime === Infinity ? '-' : gameState.bestTime;

function startGame(mode) {
    document.getElementById('modeSelect').style.display = 'none';
    document.getElementById('header').style.display = 'flex';
    document.getElementById('controlPanel').style.display = 'flex';
    gameState.mode = mode;
    initGame();
    startTimer();
}

function initGame() {
    const container = document.getElementById('gameContainer');
    container.innerHTML = '';
    const config = MODE_CONFIG[gameState.mode];
    
    // 设置容器尺寸
    container.style.width = CELL_SIZE * config.cols + 'px';
    container.style.height = CELL_SIZE * config.rows + 'px';

    // 生成图片数组
    const selected = shuffleArray(ALL_IMAGES).slice(0, config.pics);
    gameState.images = shuffleArray(selected.flatMap(id => Array(4).fill(id)));

    // 创建格子
    gameState.cells = [];
    for(let i = 0; i < config.rows * config.cols; i++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.style.width = CELL_SIZE + 'px';
        cell.style.height = CELL_SIZE + 'px';
        cell.style.left = (i % config.cols) * CELL_SIZE + 'px';
        cell.style.top = Math.floor(i / config.cols) * CELL_SIZE + 'px';
        cell.dataset.index = i;
        cell.dataset.value = gameState.images[i];
        cell.style.backgroundImage = `url('${gameState.images[i]}.png')`;
        cell.onclick = handleClick;
        container.appendChild(cell);
        gameState.cells.push(cell);
    }
}

function handleClick(e) {
    const cell = e.target;
    if (!cell.parentNode) return;

    if(gameState.selected === cell) {
        cell.style.opacity = 1;
        gameState.selected = null;
        return;
    }
    
    if(!gameState.selected) {
        cell.style.opacity = 0.7;
        gameState.selected = cell;
        return;
    }
    
    if(cell.dataset.value === gameState.selected.dataset.value) {
        const path = checkConnection(gameState.selected, cell);
        if (path) {
            eliminateCells(gameState.selected, cell, path);
        }
    }
    
    gameState.selected.style.opacity = 1;
    gameState.selected = null;
}

function checkConnection(a, b) {
    const config = MODE_CONFIG[gameState.mode];
    const grid = createGridMap();
    const start = getCellPosition(a);
    const end = getCellPosition(b);
    
    if (isAdjacent(start, end)) return [start, end];

    const queue = [{ pos: start, dir: null, turns: 0, path: [start] }];
    const visited = new Set();
    
    while (queue.length > 0) {
        const current = queue.shift();
        const key = `${current.pos.x},${current.pos.y},${current.dir},${current.turns}`;
        if (visited.has(key)) continue;
        visited.add(key);

        for (let dir of ['up', 'down', 'left', 'right']) {
            if (current.dir && getOppositeDir(current.dir) === dir) continue;
            
            const nextPos = move(current.pos, dir);
            if (!isValidPos(nextPos, config)) continue;
            
            if (samePos(nextPos, end)) return [...current.path, end];
            if (grid[nextPos.x][nextPos.y] !== 0) continue;
            
            const turns = (dir !== current.dir && current.dir) ? current.turns + 1 : current.turns;
            if (turns > 2) continue;
            
            queue.push({
                pos: nextPos,
                dir: dir,
                turns: turns,
                path: [...current.path, nextPos]
            });
        }
    }
    return null;
}

function createGridMap() {
    const config = MODE_CONFIG[gameState.mode];
    const grid = Array.from({length: config.rows}, () => 
        Array(config.cols).fill(0));
    gameState.cells.forEach(cell => {
        if (cell.parentNode) {
            const pos = getCellPosition(cell);
            grid[pos.x][pos.y] = 1;
        }
    });
    return grid;
}

function getCellPosition(cell) {
    const config = MODE_CONFIG[gameState.mode];
    const index = parseInt(cell.dataset.index);
    return {
        x: Math.floor(index / config.cols),
        y: index % config.cols
    };
}

function isAdjacent(a, b) {
    return (a.x === b.x && Math.abs(a.y - b.y) === 1) || 
           (a.y === b.y && Math.abs(a.x - b.x) === 1);
}

function move(pos, dir) {
    const moves = {
        'up': {x: -1, y: 0},
        'down': {x: 1, y: 0},
        'left': {x: 0, y: -1},
        'right': {x: 0, y: 1}
    };
    return {
        x: pos.x + moves[dir].x,
        y: pos.y + moves[dir].y
    };
}

function isValidPos(pos, config) {
    return pos.x >= 0 && pos.x < config.rows && 
           pos.y >= 0 && pos.y < config.cols;
}

function samePos(a, b) { return a.x === b.x && a.y === b.y; }

function getOppositeDir(dir) {
    return { 'up':'down', 'down':'up', 'left':'right', 'right':'left' }[dir];
}

function eliminateCells(a, b, path) {
    drawConnectionLine(path);
    setTimeout(() => {
        a.remove();
        b.remove();
        document.querySelectorAll('.path-line').forEach(line => line.remove());
        checkGameOver();
    }, 500);
}

function drawConnectionLine(path) {
    const container = document.getElementById('gameContainer');
    const config = MODE_CONFIG[gameState.mode];
    
    for (let i = 1; i < path.length; i++) {
        const prev = path[i-1];
        const curr = path[i];
        const line = document.createElement('div');
        line.className = 'path-line';

        const x1 = prev.y * CELL_SIZE + CELL_SIZE/2;
        const y1 = prev.x * CELL_SIZE + CELL_SIZE/2;
        const x2 = curr.y * CELL_SIZE + CELL_SIZE/2;
        const y2 = curr.x * CELL_SIZE + CELL_SIZE/2;

        if (prev.x === curr.x) { // 水平线
            line.style.width = `${Math.abs(x2 - x1)}px`;
            line.style.height = '4px';
            line.style.left = `${Math.min(x1, x2)}px`;
            line.style.top = `${y1 - 2}px`;
        } else { // 垂直线
            line.style.width = '4px';
            line.style.height = `${Math.abs(y2 - y1)}px`;
            line.style.left = `${x1 - 2}px`;
            line.style.top = `${Math.min(y1, y2)}px`;
        }
        container.appendChild(line);
    }
}

function checkGameOver() {
    if ([...document.getElementsByClassName('cell')].every(c => !c.parentNode)) {
        endGame();
    }
}

function startTimer() {
    gameState.startTime = Date.now();
    gameState.timerId = setInterval(() => {
        document.getElementById('timer').textContent = 
            Math.floor((Date.now() - gameState.startTime)/1000);
    }, 1000);
}

function endGame() {
    clearInterval(gameState.timerId);
    const time = Math.floor((Date.now() - gameState.startTime)/1000);
    
    if(time < gameState.bestTime) {
        gameState.bestTime = time;
        localStorage.setItem('bestTime', time);
        document.getElementById('best').textContent = time;
    }
    
    document.getElementById('dialogMask').style.display = 'block';
    document.getElementById('dialogContent').style.display = 'block';
}

function backToHome() { location.reload(); }

function restart() {
    document.getElementById('dialogMask').style.display = 'none';
    document.getElementById('dialogContent').style.display = 'none';
    clearInterval(gameState.timerId);
    initGame();
    startTimer();
    document.getElementById('round').textContent = 
        parseInt(document.getElementById('round').textContent) + 1;
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}
</script>
</body>
</html>